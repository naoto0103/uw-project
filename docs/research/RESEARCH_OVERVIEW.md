# 研究概要: HAMSTER + ManiFlow 統合による汎化能力と精度向上

**作成日**: 2025-12-19

---

## 1. 研究背景

### 1.1 ロボット操作における階層的アプローチ

近年のロボット操作研究において、Vision-Language Model（VLM）を活用した階層的なアプローチが注目を集めている。このアプローチでは、VLMが高レベルのセマンティックな理解と計画を担当し、低レベルポリシーが精密な動作制御を担当するという役割分担が行われる。この階層構造により、VLMの持つ豊富な世界知識と、低レベルポリシーの精密な制御能力を組み合わせることが可能となる。

### 1.2 HAMSTER

HAMSTER（Hierarchical Action Models for Open-World Robot Manipulation）は、この階層的アプローチを採用した代表的なモデルである。HAMSTERはVLMとLow-Level Policyの2層構造で構成される。

高レベルコンポーネントとして、HAMSTERはVILA-1.5-13Bを使用する。VILA-1.5-13BはSigLIP視覚エンコーダとVicuna言語モデルを組み合わせたVision-Language Modelであり、53億の画像テキストペアで事前学習されている。HAMSTERではこのVILAを、RGB画像とタスク記述を入力として受け取り、ロボットグリッパーが辿るべき2D経路を出力するようにファインチューニングしている。出力される経路は正規化された2D座標列とグリッパー状態（開/閉）のシーケンスとして表現される。

低レベルコンポーネントとして、HAMSTERはRVT-2または3D Diffuser Actorを使用する。これらのポリシーは、VLMが生成した2D経路をガイダンスとして受け取り、3D空間での精密なロボット制御を実現する。

HAMSTERの重要な知見として、論文のアブレーション研究（Table 3）において、経路情報の入力方法による性能差が報告されている。経路を画像上に直接オーバーレイする方法では成功率0.83であったのに対し、経路を別次元の入力として連結する方法では成功率1.00を達成した。この結果は、経路情報を独立したモダリティとして扱うことの重要性を示唆している。

### 1.3 ManiFlow

ManiFlow（Manipulation Flow）は、Consistency Flow Matchingを用いたロボット操作ポリシーである。ManiFlowの特徴は、従来のDiffusion Policyが推論時に10〜100ステップの反復的なデノイジングを必要とするのに対し、わずか1〜2ステップで高品質なアクションを生成できる点にある。

ManiFlowのアーキテクチャの中核はDiT-X（Diffusion Transformer with Cross-Attention）である。DiT-Xは、アクショントークンと観測特徴量の間でクロスアテンションを行うことで、マルチモーダルな情報統合を実現する。また、AdaLN-Zero条件付けにより、タイムステップやロボット状態に基づいた適応的な特徴変調を行う。

ManiFlowは2D画像入力と3D点群入力の両方に対応している。画像入力の場合はR3MまたはResNet-18ベースのエンコーダを使用し、点群入力の場合はPointNetベースのエンコーダを使用する。

従来のManiFlowは単一タスクのデータで学習され、その学習に使用された単一のタスクで評価が行われてきた。つまり、ManiFlowは単一タスクに特化して学習および実行を行うモデルとして設計されていた。

---

## 2. 研究目的

本研究では、HAMSTERのLow-Level Policy部分にManiFlowを適用することで、**汎化能力の向上**および**単一タスクの精度向上**を試みる。

具体的には、HAMSTERで使用されているVLM（VILA-13B）とManiFlowを組み合わせ、VILAが生成したパスをManiFlowへの入力に加える。これにより、以下の2つの効果が期待される。

---

## 3. 期待される効果

### 3.1 単一タスクのさらなる精度向上

ManiFlowはこれまで過去2ステップ分の画像とロボット状態（関節角度など）のデータを入力として受け取り、16ステップ分のアクションを生成していた。この入力画像にパスを加えることで、ManiFlowがより先の実行計画までアバウトに把握することができ、タスク実行精度の向上が期待できる。

### 3.2 汎化性能の向上

パスを入力に含めたManiFlowは、タスク実行において環境が少し変わったとしても問題なく対応できることが期待される。ManiFlowの検証で使用されるRoboTwin 2.0の評価環境には、タスクを実行するテーブルの状態の設定として、テーブルが散らかっている（cluttered）かきれいな状態かということを設定可能である。本研究では、きれいな机のデータで学習されたManiFlowでも、VILAのパスガイダンスによりclutteredな机でのタスク実行に対応することが可能になると考えている。

---

## 4. 本研究の新規性と意義

### 4.1 新規性

本研究の新規性は、HAMSTERの階層的アーキテクチャにおいて、Low-Level PolicyとしてManiFlowを採用し、VLMが生成したパスをManiFlowの入力として統合する点にある。

従来のManiFlowは単一タスクに特化したモデルであり、タスク間の汎化やドメインシフトへの対応は考慮されていなかった。本研究では、VILAが持つセマンティックな理解能力を活用することで、ManiFlowの適用範囲を拡張することを目指す。

また、パスの入力方法として、現在のパスのみを使用する方法と、初期パスと現在のパスを併用する方法（Memory Function）の2パターンを提案し、その効果を比較検証する。

### 4.2 意義

本研究の意義は、VLMの高レベルなセマンティック理解と、ManiFlowの高速かつ精密な動作生成を組み合わせることで、より実用的なロボット操作システムの実現に貢献する点にある。

特に、学習時と異なる環境での動作（汎化性能）は実世界へのロボット応用において重要な課題であり、VILAのパスガイダンスがこの課題に対する有効なアプローチとなりうることを示すことができれば、今後のロボット操作研究に対して重要な知見を提供することになる。

---

## 5. パス入力方法

### 5.1 前提

オリジナルのManiFlowは、current imageとrobot postureを入力として受け取り、robot actionを出力する。

本研究で実装したパス入力では、ManiFlowへの入力に使用される画像に、VILAが生成したパスを視覚的にオーバーレイしたものを入力画像として使用する。

### 5.2 パターン1: Current pathのみ

- 入力: current image with path + robot posture

### 5.3 パターン2: Initial path + Current path（Memory Function）

- 入力: initial image with path + current image with path + robot posture

このパターンでは、仮にオクルージョンが起きて正常なパスが生成されなかった場合に、過去のきれいなパスを参照できるようにするという役割がある。我々はこれを**Memory Function**と呼ぶ。

---

## 6. データ収集

本研究では、ManiFlowポリシーの学習に使用するデモンストレーションデータを、AgileX Cobot Magicロボットを基盤とした双腕ロボット操作プラットフォームであるRoboTwin 2.0シミュレーション環境を用いて収集した。各タスクについて、スクリプト化されたエキスパートポリシーを実行し、50本の成功軌道を生成した。

データ収集時には、各タイムステップにおいて頭部搭載カメラからのRGB観測画像、14次元のロボット固有受容状態（各アームの7自由度：関節位置およびグリッパー状態）、および対応するアクションを記録した。収集された軌道データはHDF5形式で保存される。

視覚観測に高レベルの軌道ガイダンスを付加するため、ロボット操作データでファインチューニングされた事前学習済み視覚言語モデル（VILA-1.5 13B）を用いて、各フレームに対する2次元パス予測を生成した。RGB画像と自然言語によるタスク指示を入力として、VLMは予測されるエンドエフェクタ軌道を表す正規化2次元ウェイポイント列と、グリッパー動作のアノテーションを出力する。VLMはtemperature=0で設定されているため出力は決定的であるが、一部のフレームでは指定フォーマットに従わない出力が生成される場合がある。

1回目のパス生成における失敗例を分析したところ、VLMの出力が指定フォーマット`<ans>[(x, y), ...]</ans>`に従わない以下のケースが多数確認された：

1. `<ans>`タグの省略：座標列を`<ans>`タグで囲まず直接出力するケース
2. 最初の座標の括弧欠落：先頭座標が`(x, y)`ではなく`x, y`として出力されるケース
3. 開き括弧のみの欠落：先頭座標が`x, y)`のように開き括弧だけ欠落するケース

この問題に対処するため、各フレームに対して最大2回のパス生成を試行する方式を採用した。2回目のパス生成においては、`<ans>`タグが存在しない場合でも座標データとして解釈可能な出力に対してフォールバックパース処理を適用し、上記の欠落パターンを自動補完するロジックを追加して再実行した。なお、このパース処理はモデル評価時のパス抽出ロジックにも同様に適用されており、トレーニングデータ生成時と評価時で一貫した処理を行っている。

### 6.1 学習データにおけるパス失敗時の対処方針

学習データにおけるパス生成失敗への対処は、評価時の対処方針（セクション9.2.1参照）と一致させる設計を採用した。これにより、学習時と評価時で同一のフォールバック戦略が適用され、モデルが実際のデプロイ条件に適した形で学習できる。

1. **エピソード冒頭での連続失敗時のフォールバック**: エピソードの冒頭でパス生成に連続して失敗した場合（例: frame 0, 1, 2が全て失敗）、それらのフレームには全て、そのエピソード内で最初にパス生成に成功したフレームのパスを使用する。これにより、参照すべき過去のパスが存在しない状況でも、学習データの連続性を維持できる。

2. **中間フレームのフォールバック**: パス生成に成功したフレームが存在した後に失敗した場合は、直近に生成に成功したパスを代用する。これにより、全フレームに対してパス情報を付与しつつ、学習データの連続性を維持する。

3. **フォールバック使用数の記録**: 各エピソードでフォールバックパスを使用したフレーム数を記録し、学習データの品質を定量的に把握できるようにする。Frame 0でのパス生成成功率も補助指標として記録する。

4. **学習・評価間の一貫性**: この方針により、学習データと評価時の入力分布が一致し、ドメインシフトを軽減できる。実世界でのデプロイにおいてもVLMの出力が常に成功するとは限らないため、失敗時のリカバリー戦略を学習時から経験させることは、システム全体の頑健性向上に寄与する。

これらの予測パスは、時間的進行をjetカラーマップでエンコードした色付きオーバーレイとして元のRGB画像上に描画され、グリッパー状態の変化点には円形マーカーが付与される。得られたオーバーレイ画像はポリシーネットワークへの視覚入力として使用され、高レベルのタスク理解と低レベルの運動制御を橋渡しする意図された操作軌道の明示的な表現を提供する。

### 6.2 パス生成統計

学習データ生成時のVILAパス生成結果を以下に示す。各フレームに対して最大2回のパス生成を試行し（1回目: 全フレーム、2回目: 失敗フレームのリトライ）、temperature=0で決定的に生成した。

#### Clean Table条件

| タスク | エピソード数 | フレーム数 | Raw出力数 | パス抽出成功数 | 成功率 |
|--------|-------------|-----------|----------|--------------|--------|
| click_bell | 50 | 3,904 | 3,904 | 3,867 | 99.1% |
| turn_switch | 50 | 4,985 | 4,985 | 4,922 | 98.7% |
| move_can_pot | 50 | 7,593 | 7,593 | 7,573 | 99.7% |
| open_microwave | 50 | 30,688 | 30,688 | 27,302 | 89.0% |
| adjust_bottle | 50 | 7,075 | 7,075 | 6,939 | 98.1% |
| beat_block_hammer | 50 | 5,758 | 5,758 | 5,758 | 100.0% |
| **合計** | **300** | **60,003** | **60,003** | **56,361** | **93.9%** |

#### Cluttered Table条件

| タスク | エピソード数 | フレーム数 | Raw出力数 | パス抽出成功数 | 成功率 |
|--------|-------------|-----------|----------|--------------|--------|
| click_bell | 50 | 3,918 | 3,918 | 3,788 | 96.7% |
| turn_switch | 50 | 4,939 | 4,939 | 4,911 | 99.4% |
| move_can_pot | 50 | 7,665 | 7,665 | 7,489 | 97.7% |
| open_microwave | 50 | 33,971 | 33,971 | 31,251 | 92.0% |
| adjust_bottle | 50 | 7,080 | 7,080 | 5,796 | 81.9% |
| beat_block_hammer | 50 | 5,726 | 5,726 | 5,668 | 99.0% |
| **合計** | **300** | **63,299** | **63,299** | **58,903** | **93.1%** |

**考察**:
- open_microwaveはエピソード長が長く（30k-34kフレーム）、成功率が89-92%とやや低い。これはドア開閉時のオクルージョンが原因である可能性が考えられる
- adjust_bottle（cluttered）は81.9%と最も低い成功率を示した。テーブル上のオブジェクトによる視覚的干渉が影響している可能性が考えられる
- パス抽出に失敗したフレームには、セクション6.1のフォールバック戦略（first_successful_path / last_successful_path）が適用され、全フレームにパスオーバーレイが付与される

---

## 7. 実験条件

全ての条件において、評価はRoboTwin 2.0のcluttered table条件で行う。

### 条件一覧表

|  | オリジナルManiFlow | VILA + ManiFlow (current) | VILA + ManiFlow (initial + current) |
|--|-------------------|---------------------------|-------------------------------------|
| **学習: cluttered** | 条件1 | 条件2 | 条件3 |
| **学習: clean** | 条件4 | 条件5 | 条件6 |

### 条件1

- モデル: オリジナルManiFlow
- 学習データ: RoboTwin 2.0, cluttered table条件
- 評価データ: RoboTwin 2.0, cluttered table条件

### 条件2

- モデル: VILA-13B + ManiFlow (current pathのみ)
- 学習データ: RoboTwin 2.0, cluttered table条件
- 評価データ: RoboTwin 2.0, cluttered table条件

### 条件3

- モデル: VILA-13B + ManiFlow (initial path + current path)
- 学習データ: RoboTwin 2.0, cluttered table条件
- 評価データ: RoboTwin 2.0, cluttered table条件

### 条件4

- モデル: オリジナルManiFlow
- 学習データ: RoboTwin 2.0, clean table条件
- 評価データ: RoboTwin 2.0, cluttered table条件

### 条件5

- モデル: VILA-13B + ManiFlow (current pathのみ)
- 学習データ: RoboTwin 2.0, clean table条件
- 評価データ: RoboTwin 2.0, cluttered table条件

### 条件6

- モデル: VILA-13B + ManiFlow (initial path + current path)
- 学習データ: RoboTwin 2.0, clean table条件
- 評価データ: RoboTwin 2.0, cluttered table条件

---

## 8. 検証する仮説

### H1: VILAのパスガイダンスは単一タスク精度を向上させる

- 検証方法: 条件1 vs 条件2, 条件3の比較
- 同一ドメイン（cluttered→cluttered）において、VILAが生成したパスを入力に加えることで、ManiFlow単体より性能が向上するかを検証する

### H2: VILAのパスガイダンスは汎化性能を向上させる

- 検証方法: 条件4 vs 条件5, 条件6の比較
- ドメインギャップ（clean→cluttered）がある条件において、VILAのセマンティックなガイダンスが性能低下を軽減するかを検証する

### H3: Initial pathの追加はcurrent pathのみより性能を向上させる

- 検証方法: 条件2 vs 条件3、条件5 vs 条件6の比較
- タスクの全体像（initial path）を追加で与えることで、current pathのみの場合より高い性能が得られるかを検証する

### H4: パスガイダンスの効果はドメインギャップ条件でより顕著である

- 検証方法: (条件2-条件1) vs (条件5-条件4)、(条件3-条件1) vs (条件6-条件4)の比較
- ドメインギャップ条件での改善幅がin-domain条件より大きければ、VILAのパスが汎化のブリッジとして機能している証拠となる

---

## 9. 評価方法

### 9.1 評価環境

評価はRoboTwin 2.0シミュレーション環境（SAPIEN 3.0.0b1ベース）上で実行する。全ての条件においてcluttered table設定を使用する。

### 9.2 評価時の推論フロー

評価時には、ManiFlowが16ステップ分のアクションを一度に予測し、それを順次実行する。パス生成は毎フレームではなく16ステップごとに行われる。

- **Step 0**: VILAによるパス生成 → initial_overlayおよびcurrent_overlay作成 → ManiFlowが16ステップ分のアクションを一括予測
- **Step 1-15**: 予測済みアクションを順次実行
- **Step 16**: 新規パス生成 → current_overlay更新 → 次の16ステップ分のアクションを一括予測
- 以降、16ステップごとに繰り返し

initial_overlayはエピソード開始時に作成され、エピソード終了まで固定される。current_overlayは16ステップごとに更新される。

### 9.2.1 評価時のパス失敗への対処

評価時のパス生成失敗への対処は、HAMSTERの評価方針を踏襲する。HAMSTERでは評価時にパス生成が失敗した場合のリカバリー機能はなく、不適切なパスが生成されてタスクが失敗した場合は通常通り失敗としてカウントされる。

本研究でも同様に、パス生成の失敗による影響も含めたシステム全体の性能として評価を行う：

1. **パス生成失敗時の対処**: パス生成に失敗した場合は最大2回までリトライする。それでも失敗した場合は、直前に成功したパスを再利用して継続する。

2. **Frame 0での失敗**: エピソード開始時（frame 0）でパス生成に失敗した場合、最初の入力画像はオーバーレイなしで処理し、以降は最初にパス生成に成功したフレームのパスをinitial_pathとして使用する。

3. **失敗のカウント**: パス生成の失敗により誤った動作が発生し、タスクが失敗した場合は、通常通り失敗としてカウントする。これにより、VLMのパス生成能力も含めたシステム全体の実用的な性能を評価できる。

4. **補助指標としての記録**: 評価時のframe 0パス生成成功率を補助指標として記録し、論文に報告する。これにより、実験結果の透明性を確保する。

### 9.3 評価に使用するタスク

本研究では、RoboTwin 2.0のシングルアームタスク（35タスク）の中から、以下の3タスクを選択して評価を行う。

| # | タスク名 | 説明 | 選択理由 |
|---|----------|------|----------|
| 1 | click_bell | ベルをクリック | シンプルな単一動作。ベースラインとして最も基本的なタスク |
| 2 | move_can_pot | 缶をポットの横に移動 | Pick-and-Placeの基本形。物体操作の標準的なタスク |
| 3 | beat_block_hammer | ハンマーでブロックを叩く | 道具使用を含む複雑なタスク。ハンマーを掴んで叩く2段階動作 |

**選択理由**

これら3タスクは、以下の観点から選択した。

**難易度のグラデーション**: click_bellは単純なクリック動作、move_can_potは標準的なPick-and-Place、beat_block_hammerは道具使用を要するタスクであり、シンプルなものから複雑なものまで段階的にカバーしている。

**動作パターンの多様性**: 単一接触動作（click）、物体移動（move）、道具使用（beat）という異なる動作カテゴリを含んでおり、パスガイダンスの効果を多角的に検証できる。

**シングルアームタスクへの統一**: 本研究ではシングルアームタスクに焦点を当てている。

### 9.4 評価指標

#### 主要指標

**タスク成功率**: 各タスクの評価において、100回の試行を行い、その成功率を求める。成功判定はRoboTwin 2.0の内蔵判定エンジンを使用する。

**トレーニング動作誤差（MSE）**: モデルトレーニングにおける収束速度や学習の安定性を評価する。

**推論速度**: VILAがパスを生成する時間と、ManiFlowが16ステップ分のアクションを一度に生成する時間をそれぞれ測定する。オリジナルのManiFlowと比較し、パス生成によるオーバーヘッドを定量化する。

#### 補助指標

**パス生成成功率**: VILAが有効なパスを出力できた割合を測定する。パス生成が失敗した場合は最大5回までリトライし、それでも失敗した場合は直近で生成された有効なパスを再利用する。

### 9.5 エピソード数

**学習**: 各タスク50エピソード

**評価**: 各タスク100エピソード

