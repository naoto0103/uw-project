#!/usr/bin/env python3
"""
Create visualization videos for RoboTwin 2.0 single-arm PEEK path generation results.

PEEK outputs trajectory as numpy array of (x, y) points without gripper state.
Uses green lines for path and yellow ring for start point.

Works with paths generated by PEEK model (trajectory_frame_*.pkl format).
"""

import os
import sys
import pickle
import cv2
import numpy as np
from pathlib import Path
from typing import List, Tuple, Optional
import json


def draw_peek_path_on_image(
    image: np.ndarray,
    path: np.ndarray,
) -> np.ndarray:
    """
    Draw PEEK path on image.

    Color scheme:
    - Green lines for path
    - Yellow ring for start point
    - Cyan ring for end point

    Args:
        image: Image array (H, W, 3) in BGR format
        path: Numpy array of shape (N, 2) with (x, y) normalized to [0, 1]

    Returns:
        Image with path drawn (BGR format)
    """
    if path is None or len(path) == 0:
        return image

    img = image.copy()
    h, w = img.shape[:2]

    # Calculate scale factor
    scale_factor = max(min(w, h) / 512.0, 1)
    circle_radius = int(7 * scale_factor)
    line_thickness = max(1, int(3 * scale_factor))

    # Convert normalized coordinates to pixel coordinates
    pixel_points = []
    for point in path:
        x, y = point[0], point[1]
        px = int(x * w)
        py = int(y * h)
        pixel_points.append((px, py))

    # Draw path lines in green
    for i in range(len(pixel_points) - 1):
        color = (0, 255, 0)  # Green in BGR
        cv2.line(img, pixel_points[i], pixel_points[i+1], color, line_thickness)

    # Mark start point with yellow circle
    if pixel_points:
        cv2.circle(img, pixel_points[0], circle_radius + 3, (0, 255, 255), 2)

    # Mark end point with cyan circle
    if len(pixel_points) > 1:
        cv2.circle(img, pixel_points[-1], circle_radius, (255, 255, 0), -1)

    return img


def visualize_and_create_video(
    task_name: str,
    episode_num: int,
    base_dir: Path,
    fps: int = 50,
    verbose: bool = True
) -> dict:
    """
    Visualize PEEK paths on frames and create video for one episode.

    Args:
        task_name: Task name
        episode_num: Episode number
        base_dir: Base directory
        fps: Video frames per second (default 50Hz)
        verbose: Print progress

    Returns:
        Result dictionary
    """
    episode_dir = base_dir / task_name / f"episode_{episode_num:02d}"
    frames_dir = episode_dir / "frames"
    paths_dir = episode_dir / "paths"
    output_frames_dir = episode_dir / "frames_with_paths"
    output_video = episode_dir / "path_video_peek.mp4"

    if verbose:
        print(f"    Frames: {frames_dir}")
        print(f"    Paths: {paths_dir}")

    # Check directories
    if not frames_dir.exists():
        return {"status": "error", "error": "Frames not found"}
    if not paths_dir.exists():
        return {"status": "error", "error": "Paths not found"}

    # Get frames and paths (PEEK uses trajectory_frame_*.pkl)
    frame_files = sorted(frames_dir.glob("frame_*.png"))
    path_files = sorted(paths_dir.glob("trajectory_frame_*.pkl"))

    num_frames = len(frame_files)
    num_paths = len(path_files)

    if verbose:
        print(f"    Found {num_frames} frames, {num_paths} paths")

    if num_frames == 0:
        return {"status": "error", "error": "No frames"}
    if num_paths == 0:
        return {"status": "error", "error": "No paths"}

    # Create output directory
    os.makedirs(output_frames_dir, exist_ok=True)

    # Read first frame to get dimensions
    first_frame = cv2.imread(str(frame_files[0]))
    height, width = first_frame.shape[:2]

    if verbose:
        print(f"    Frame size: {width}x{height}")

    # Create video writer
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(
        str(output_video),
        fourcc,
        fps,
        (width, height)
    )

    if not video_writer.isOpened():
        return {"status": "error", "error": "Failed to create video writer"}

    # Process each frame
    success_count = 0
    fail_count = 0
    frames_with_path = 0

    for i, frame_file in enumerate(frame_files):
        frame_num = i

        # Load frame
        frame = cv2.imread(str(frame_file))
        if frame is None:
            fail_count += 1
            continue

        # Load path (PEEK format: trajectory_frame_*.pkl)
        path_file = paths_dir / f"trajectory_frame_{frame_num:04d}.pkl"
        if path_file.exists():
            with open(path_file, 'rb') as f:
                path = pickle.load(f)

            # Draw path on frame (PEEK format: numpy array of (x, y))
            frame_with_path = draw_peek_path_on_image(frame, path)
            frames_with_path += 1
        else:
            frame_with_path = frame

        # Save visualized frame
        output_frame_file = output_frames_dir / f"frame_{frame_num:04d}.png"
        cv2.imwrite(str(output_frame_file), frame_with_path)

        # Write to video
        video_writer.write(frame_with_path)
        success_count += 1

        if verbose and (i + 1) % 50 == 0:
            print(f"      Processed {i + 1}/{num_frames} frames...")

    video_writer.release()

    # Check file size
    if output_video.exists():
        file_size_mb = output_video.stat().st_size / 1024 / 1024
    else:
        file_size_mb = 0

    if verbose:
        print(f"    Video created: {output_video}")
        print(f"    Video size: {file_size_mb:.2f} MB")
        print(f"    Duration: {num_frames / fps:.1f} seconds @ {fps}Hz")
        print(f"    Frames with path overlay: {frames_with_path}/{num_frames}")

    return {
        "status": "success",
        "frames": num_frames,
        "paths": num_paths,
        "frames_with_path": frames_with_path,
        "success": success_count,
        "failed": fail_count,
        "video": str(output_video),
        "video_size_mb": file_size_mb,
        "duration_sec": num_frames / fps,
    }


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="Create visualization videos for RoboTwin 2.0 single-arm PEEK paths"
    )
    parser.add_argument("--tasks", type=str, nargs="+",
                        default=["move_can_pot"],
                        help="Tasks to process")
    parser.add_argument("--episodes", type=int, default=1,
                        help="Number of episodes per task")
    parser.add_argument("--start-episode", type=int, default=0,
                        help="Starting episode number")
    parser.add_argument("--base-dir", type=str, default=None,
                        help="Base directory")
    parser.add_argument("--fps", type=int, default=50,
                        help="Video FPS (default: 50Hz)")
    parser.add_argument("--verbose", action="store_true",
                        help="Print detailed output")

    args = parser.parse_args()

    # Set directories
    script_dir = Path(__file__).parent.absolute()
    if args.base_dir is None:
        base_dir = script_dir.parent / "results" / "robotwin2_single_6tasks_peek"
    else:
        base_dir = Path(args.base_dir)

    print("=" * 80)
    print("RoboTwin 2.0 Single-Arm Video Creation (PEEK)")
    print("=" * 80)
    print(f"Tasks: {args.tasks}")
    print(f"Episodes: {args.start_episode} to {args.start_episode + args.episodes - 1}")
    print(f"Base directory: {base_dir}")
    print(f"FPS: {args.fps}Hz")
    print()
    print("Color scheme (PEEK):")
    print("  Green lines = path trajectory")
    print("  Yellow ring = start point")
    print("  Cyan circle = end point")
    print()

    # Process episodes
    results = []

    for task_idx, task_name in enumerate(args.tasks):
        print("-" * 60)
        print(f"Task [{task_idx + 1}/{len(args.tasks)}]: {task_name}")
        print("-" * 60)

        for ep_idx in range(args.start_episode, args.start_episode + args.episodes):
            print(f"\n  Episode: episode_{ep_idx:02d}")

            result = visualize_and_create_video(
                task_name=task_name,
                episode_num=ep_idx,
                base_dir=base_dir,
                fps=args.fps,
                verbose=True
            )
            result["task"] = task_name
            result["episode"] = ep_idx
            results.append(result)

    # Summary
    print()
    print("=" * 80)
    print("Video Creation Summary")
    print("=" * 80)

    success_count = sum(1 for r in results if r["status"] == "success")
    total_videos = len(results)

    print(f"Total episodes: {total_videos}")
    print(f"Videos created: {success_count}")
    print()

    # Print results table
    print(f"{'Task':<25} {'Ep':<4} {'Status':<10} {'Frames':<8} {'Paths':<8} {'Duration':<10} {'Size':<8}")
    print("-" * 85)
    for r in results:
        duration = f"{r.get('duration_sec', 0):.1f}s" if 'duration_sec' in r else "N/A"
        size = f"{r.get('video_size_mb', 0):.1f}MB" if 'video_size_mb' in r else "N/A"
        paths = r.get('frames_with_path', r.get('paths', 0))
        print(f"{r['task']:<25} {r['episode']:<4} {r['status']:<10} {r.get('frames', 0):<8} {paths:<8} {duration:<10} {size:<8}")

    print("=" * 80)


if __name__ == "__main__":
    main()
