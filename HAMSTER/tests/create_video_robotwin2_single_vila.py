#!/usr/bin/env python3
"""
Create visualization videos for RoboTwin 2.0 single-arm VILA path generation results.

Uses HAMSTER standard drawing style:
- Green lines for path
- Red markers for gripper close
- Blue markers for gripper open
- Yellow ring for start point

Path handling policy (consistent with training data generation):
- If early frames (frame 0, 1, 2...) have no path, use the first successful path
- If a frame after a successful path has no path, use the most recent successful path
- This ensures all frames in the video have path overlays

Works with paths generated by generate_paths_robotwin2_single_vila.py
"""

import os
import sys
import pickle
import cv2
import numpy as np
from pathlib import Path
from typing import List, Tuple, Optional
import json

# HAMSTER drawing constants
GRIPPER_CLOSE = 0
GRIPPER_OPEN = 1

# Single-arm tasks (6 tasks from VILA generation)
SINGLE_ARM_TASKS = [
    "beat_block_hammer",
    "click_bell",
    "move_can_pot",
    "open_microwave",
    "place_object_stand",
    "turn_switch",
]

# Task instructions
SINGLE_ARM_INSTRUCTIONS = {
    "beat_block_hammer": "Pick up the hammer and beat the block",
    "click_bell": "Click the bell's top center on the table",
    "move_can_pot": "Pick up the can and move it to beside the pot",
    "open_microwave": "Open the microwave",
    "place_object_stand": "Place the object on the stand",
    "turn_switch": "Click the switch",
}


def draw_single_path_on_image(
    image: np.ndarray,
    path: List[Tuple[float, float, int]],
) -> np.ndarray:
    """
    Draw single-arm path on image using HAMSTER standard style.

    Color scheme:
    - Green lines for path
    - Red markers for gripper close
    - Blue markers for gripper open
    - Yellow ring for start point

    Args:
        image: Image array (H, W, 3) in BGR format
        path: List of (x, y, gripper_state) tuples, normalized to [0, 1]

    Returns:
        Image with path drawn (BGR format)
    """
    if not path or len(path) == 0:
        return image

    img = image.copy()
    h, w = img.shape[:2]

    # Calculate scale factor (HAMSTER original logic)
    scale_factor = max(min(w, h) / 512.0, 1)
    circle_radius = int(7 * scale_factor)
    line_thickness = max(1, int(3 * scale_factor))

    # Convert normalized coordinates to pixel coordinates
    pixel_points = []
    gripper_status = []
    for x, y, action in path:
        px = int(x * w)
        py = int(y * h)
        pixel_points.append((px, py))
        gripper_status.append(action)

    # Draw path lines in green (HAMSTER original)
    for i in range(len(pixel_points) - 1):
        color = (0, 255, 0)  # Green in BGR
        cv2.line(img, pixel_points[i], pixel_points[i+1], color, line_thickness)

    # Draw markers at gripper state change points (HAMSTER original)
    for idx, (x, y) in enumerate(pixel_points):
        if idx == 0 or gripper_status[idx] != gripper_status[idx - 1]:
            # Red=close, Blue=open (HAMSTER original)
            circle_color = (0, 0, 255) if gripper_status[idx] == GRIPPER_CLOSE else (255, 0, 0)
            cv2.circle(img, (x, y), circle_radius, circle_color, -1)

    # Mark start point with yellow circle (HAMSTER original)
    if pixel_points:
        cv2.circle(img, pixel_points[0], circle_radius + 3, (0, 255, 255), 2)

    return img


def visualize_and_create_video(
    task_name: str,
    episode_num: int,
    base_dir: Path,
    fps: int = 50,
    verbose: bool = True
) -> dict:
    """
    Visualize paths on frames and create video for one episode.

    Path handling policy (consistent with training data generation):
    - If early frames (frame 0, 1, 2...) have no path, use the first successful path
    - If a frame after a successful path has no path, use the most recent successful path
    - This ensures all frames in the video have path overlays

    Args:
        task_name: Task name
        episode_num: Episode number
        base_dir: Base directory
        fps: Video frames per second (default 50Hz)
        verbose: Print progress

    Returns:
        Result dictionary
    """
    episode_dir = base_dir / task_name / f"episode_{episode_num:02d}"
    frames_dir = episode_dir / "frames"
    paths_dir = episode_dir / "paths"
    output_frames_dir = episode_dir / "frames_with_paths"
    output_video = episode_dir / "path_video_vila.mp4"

    if verbose:
        print(f"    Frames: {frames_dir}")
        print(f"    Paths: {paths_dir}")

    # Check directories
    if not frames_dir.exists():
        return {"status": "error", "error": "Frames not found"}
    if not paths_dir.exists():
        return {"status": "error", "error": "Paths not found"}

    # Get frames and paths
    frame_files = sorted(frames_dir.glob("frame_*.png"))
    path_files = sorted(paths_dir.glob("path_frame_*.pkl"))

    num_frames = len(frame_files)
    num_paths = len(path_files)

    if verbose:
        print(f"    Found {num_frames} frames, {num_paths} paths")

    if num_frames == 0:
        return {"status": "error", "error": "No frames"}
    if num_paths == 0:
        return {"status": "error", "error": "No paths"}

    # Find the first successful path in the episode
    first_successful_path = None
    first_successful_frame = None
    for frame_file in frame_files:
        frame_num = int(frame_file.stem.split('_')[1])
        path_file = paths_dir / f"path_frame_{frame_num:04d}.pkl"
        if path_file.exists():
            try:
                with open(path_file, 'rb') as f:
                    path_data = pickle.load(f)
                if path_data and len(path_data) > 0:
                    first_successful_path = path_data
                    first_successful_frame = frame_num
                    break
            except Exception:
                continue

    # If no valid path found in the entire episode, skip it
    if first_successful_path is None:
        return {"status": "skipped", "error": "No valid path found in entire episode"}

    # Create output directory
    os.makedirs(output_frames_dir, exist_ok=True)

    # Read first frame to get dimensions
    first_frame = cv2.imread(str(frame_files[0]))
    height, width = first_frame.shape[:2]

    if verbose:
        print(f"    Frame size: {width}x{height}")

    # Create video writer
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(
        str(output_video),
        fourcc,
        fps,
        (width, height)
    )

    if not video_writer.isOpened():
        return {"status": "error", "error": "Failed to create video writer"}

    # Process each frame
    success_count = 0
    fail_count = 0
    frames_with_path = 0
    fallback_count = 0
    early_fallback_count = 0

    # Track the most recent successful path for fallback
    last_successful_path = None

    for i, frame_file in enumerate(frame_files):
        frame_num = i

        # Load frame
        frame = cv2.imread(str(frame_file))
        if frame is None:
            fail_count += 1
            continue

        # Try to load path for this frame
        path_file = paths_dir / f"path_frame_{frame_num:04d}.pkl"
        current_path = None
        used_fallback = False

        if path_file.exists():
            try:
                with open(path_file, 'rb') as f:
                    current_path = pickle.load(f)
                if current_path and len(current_path) > 0:
                    last_successful_path = current_path
                else:
                    current_path = None
            except (EOFError, pickle.UnpicklingError):
                current_path = None

        # Use fallback if no valid path for this frame
        if current_path is None:
            if last_successful_path is not None:
                # After a successful path, use the most recent one
                current_path = last_successful_path
                used_fallback = True
            else:
                # Early frames before first success: use first successful path
                current_path = first_successful_path
                used_fallback = True
                early_fallback_count += 1

        # Draw path on frame
        frame_with_path = draw_single_path_on_image(frame, current_path)
        frames_with_path += 1
        if used_fallback:
            fallback_count += 1

        # Save visualized frame
        output_frame_file = output_frames_dir / f"frame_{frame_num:04d}.png"
        cv2.imwrite(str(output_frame_file), frame_with_path)

        # Write to video
        video_writer.write(frame_with_path)
        success_count += 1

        if verbose and (i + 1) % 50 == 0:
            print(f"      Processed {i + 1}/{num_frames} frames...")

    video_writer.release()

    # Check file size
    if output_video.exists():
        file_size_mb = output_video.stat().st_size / 1024 / 1024
    else:
        file_size_mb = 0

    if verbose:
        print(f"    Video created: {output_video}")
        print(f"    Video size: {file_size_mb:.2f} MB")
        print(f"    Duration: {num_frames / fps:.1f} seconds @ {fps}Hz")
        print(f"    Frames with path overlay: {frames_with_path}/{num_frames}")
        print(f"    Frames using fallback path: {fallback_count}")

    return {
        "status": "success",
        "frames": num_frames,
        "paths": num_paths,
        "frames_with_path": frames_with_path,
        "fallback_used": fallback_count,
        "early_fallback_used": early_fallback_count,
        "first_successful_frame": first_successful_frame,
        "success": success_count,
        "failed": fail_count,
        "video": str(output_video),
        "video_size_mb": file_size_mb,
        "duration_sec": num_frames / fps,
    }


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="Create visualization videos for RoboTwin 2.0 single-arm VILA paths"
    )
    parser.add_argument("--tasks", type=str, nargs="+", default=SINGLE_ARM_TASKS,
                        help="Tasks to process")
    parser.add_argument("--episodes", type=int, default=1,
                        help="Number of episodes per task")
    parser.add_argument("--base-dir", type=str, default=None,
                        help="Base directory")
    parser.add_argument("--fps", type=int, default=50,
                        help="Video FPS (default: 50Hz)")
    parser.add_argument("--verbose", action="store_true",
                        help="Print detailed output")

    args = parser.parse_args()

    # Set directories - use robotwin2_single_6tasks_vila
    script_dir = Path(__file__).parent.absolute()
    if args.base_dir is None:
        base_dir = script_dir.parent / "results" / "robotwin2_single_6tasks_vila"
    else:
        base_dir = Path(args.base_dir)

    print("=" * 80)
    print("RoboTwin 2.0 Single-Arm Video Creation (VILA)")
    print("=" * 80)
    print(f"Tasks: {args.tasks}")
    print(f"Episodes per task: {args.episodes}")
    print(f"Base directory: {base_dir}")
    print(f"FPS: {args.fps}Hz")
    print()
    print("Color scheme (HAMSTER standard):")
    print("  Green lines = path trajectory")
    print("  Red markers = gripper close")
    print("  Blue markers = gripper open")
    print("  Yellow ring = start point")
    print()

    # Process episodes
    results = []

    for task_idx, task_name in enumerate(args.tasks):
        print("-" * 60)
        print(f"Task [{task_idx + 1}/{len(args.tasks)}]: {task_name}")
        print(f"Instruction: {SINGLE_ARM_INSTRUCTIONS.get(task_name, 'N/A')}")
        print("-" * 60)

        for ep_idx in range(args.episodes):
            print(f"\n  Episode [{ep_idx + 1}/{args.episodes}]: episode_{ep_idx:02d}")

            result = visualize_and_create_video(
                task_name=task_name,
                episode_num=ep_idx,
                base_dir=base_dir,
                fps=args.fps,
                verbose=True
            )
            result["task"] = task_name
            result["episode"] = ep_idx
            results.append(result)

    # Summary
    print()
    print("=" * 80)
    print("Video Creation Summary")
    print("=" * 80)

    success_episodes = [r for r in results if r["status"] == "success"]
    skipped_episodes = [r for r in results if r["status"] == "skipped"]
    error_episodes = [r for r in results if r["status"] == "error"]

    total_videos = len(results)
    total_fallback = sum(r.get("fallback_used", 0) for r in success_episodes)
    total_early_fallback = sum(r.get("early_fallback_used", 0) for r in success_episodes)

    # Count episodes where frame 0 failed (first_successful_frame > 0)
    episodes_with_frame0_fail = [r for r in success_episodes if r.get("first_successful_frame", 0) > 0]

    print(f"Total episodes: {total_videos}")
    print(f"Videos created: {len(success_episodes)}")
    print(f"Episodes skipped (no valid path): {len(skipped_episodes)}")
    print(f"Episodes with frame 0 failure: {len(episodes_with_frame0_fail)}")
    print(f"Episodes with errors: {len(error_episodes)}")
    print(f"Total frames using fallback path: {total_fallback}")
    print(f"Total early fallback frames: {total_early_fallback}")
    print()

    # Print results table
    print(f"{'Task':<25} {'Ep':<4} {'Status':<10} {'Frames':<8} {'Fallback':<10} {'Duration':<10} {'Size':<8}")
    print("-" * 90)
    for r in results:
        duration = f"{r.get('duration_sec', 0):.1f}s" if 'duration_sec' in r else "N/A"
        size = f"{r.get('video_size_mb', 0):.1f}MB" if 'video_size_mb' in r else "N/A"
        fallback = r.get('fallback_used', 0)
        print(f"{r['task']:<25} {r['episode']:<4} {r['status']:<10} {r.get('frames', 0):<8} {fallback:<10} {duration:<10} {size:<8}")

    # List skipped episodes
    if skipped_episodes:
        print()
        print("Skipped episodes (no frame 0 path):")
        for r in skipped_episodes:
            print(f"  - {r['task']}/episode_{r['episode']:02d}: {r.get('error', 'Unknown')}")

    # Save summary
    os.makedirs(base_dir, exist_ok=True)
    summary_file = base_dir / "video_creation_summary_vila.json"
    with open(summary_file, 'w') as f:
        json.dump({
            "model": "VILA-1.5-13B (HAMSTER finetuned)",
            "arm_type": "single",
            "total_episodes": total_videos,
            "videos_created": len(success_episodes),
            "skipped_episodes": len(skipped_episodes),
            "skipped_episode_list": [{"task": r["task"], "episode": r["episode"]} for r in skipped_episodes],
            "episodes_with_frame0_fail": len(episodes_with_frame0_fail),
            "frame0_fail_episode_list": [{"task": r["task"], "episode": r["episode"], "first_successful_frame": r["first_successful_frame"]} for r in episodes_with_frame0_fail],
            "total_fallback_used": total_fallback,
            "total_early_fallback_used": total_early_fallback,
            "fps": args.fps,
            "results": results,
        }, f, indent=2)

    print()
    print(f"Summary saved to: {summary_file}")
    print()
    print("Videos location:")
    for r in results:
        if r["status"] == "success":
            print(f"  {r['video']}")
    print("=" * 80)


if __name__ == "__main__":
    main()
